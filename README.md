# Community API

[>실행 방법 보러가기](HOW_TO_RUN.md)

1. [개요 (Overview)](#1-개요-overview)
    - 1.1 [프로젝트 목표](#11-프로젝트-목표)
    - 1.2 [주요 기능](#12-주요-기능)
    - 1.3 [학습 목표](#13-학습-목표)
    - 1.4 [기술 스택](#14-기술-스택)
2. [시스템 아키텍처 (System Architecture)](#2-시스템-아키텍처-system-architecture)
    - 2.1 [레이어드 아키텍처](#21-레이어드-아키텍처)
    - 2.2 [주요 컴포넌트](#22-주요-컴포넌트)
      - 2.2.1 [도메인 관리 컴포넌트](#221-도메인-관리-컴포넌트)
      - 2.2.2 [인증 및 JWT 관리](#222-인증-및-jwt-관리)
      - 2.2.3 [권한 관리](#223-권한-관리)
    - 2.3 [데이터베이스 설계](#23-데이터베이스-설계)
      - [테이블 간의 주요 관계](#테이블-간의-주요-관계)
3. [테스트 및 검증 (Testing & Validation)](#3-테스트-및-검증-testing--validation)
    - 3.1 [유닛 테스트](#31-유닛-테스트)
    - 3.2 [통합 테스트](#32-통합-테스트)
    - 3.3 [기능 테스트](#33-기능-테스트)
4. [에러 처리 (Error Handling)](#4-에러-처리-error-handling)
    - 4.1 [전역 예외 처리](#41-전역-예외-처리)
    - 4.2 [스프링 시큐리티 예외 처리](#42-스프링-시큐리티-예외-처리)
    - 4.3 [HTTP 상태 코드 매핑](#43-http-상태-코드-매핑)
    - 4.4 [에러 메시지 반환](#44-에러-메시지-반환)
5. [인증 및 보안 (Authentication & Security)](#5-인증-및-보안-authentication--security)
    - 5.1 [인증](#51-인증)
    - 5.2 [JWT 구성 및 처리](#52-jwt-구성-및-처리)
    - 5.3 [권한 관리](#53-권한-관리)
    - 5.4 [보안 적용](#54-보안-적용)
    - 5.5 [세션 관리](#55-세션-관리)

---

## 1. 개요 (Overview)
### 1.1 프로젝트 목표
백엔드 개발을 공부하기 위해 기획된 토이 프로젝트입니다. RESTful API의 기본적인 개념을 학습하고, 이를 실제로 구현하는 과정을 통해 Spring Boot, Spring Security, JPA, Docker 등 주요 백엔드 기술 스택을 익히는 것이 주된 목적입니다. 여러 게시판을 관리하고, 각 게시판에 게시글을 작성하고 조회하며, 댓글 기능을 통해 사용자 간의 상호작용을 가능하게 하는 커뮤니티 플랫폼을 개발하는 것입니다. 특히, CRUD 기능(Create, Read, Update, Delete)을 중심으로 하여 RESTful API의 동작 원리를 학습하고, 이를 통해 다양한 엔드포인트를 구현하는 데 중점을 두었습니다.

### 1.2 주요 기능
- **인증 및 JWT 관리 (Authentication & JWT Management)**: 회원가입, 로그인, JWT 토큰 발급 및 갱신을 통한 인증 처리. 클라이언트는 JWT 토큰을 사용하여 서버와 통신하며, 인증된 사용자만 시스템에 접근할 수 있습니다.
- **사용자 관리 (User Management)**: 사용자 정보 조회, 수정, 삭제와 같은 사용자 객체에 대한 CRUD 기능을 제공합니다.
- **게시판 관리 (Board Management)**: 게시판의 생성, 수정, 삭제, 조회 기능을 제공하여 게시판을 관리합니다.
- **게시글 관리 (Post Management)**: 게시글 작성, 수정, 삭제, 조회 기능을 제공하며, 게시글에 대한 즐겨찾기(좋아요) 기능도 지원합니다.
- **댓글 관리 (Comment Management)**: 게시글에 대한 댓글 작성, 수정, 삭제, 조회 기능을 제공합니다.
- **역할 관리 (Role Management)**: 역할 객체에 대한 생성, 수정, 삭제, 조회 기능을 제공합니다.
- **권한 관리 (Authorization Management)**: 사용자의 역할에 따라 시스템의 특정 리소스나 기능에 대한 접근을 제한합니다. 예를 들어, 특정 게시판은 특정 역할 이상을 가진 사용자만 열람하거나 수정할 수 있습니다.

### 1.3 학습 목표
1. **RESTful API 설계 및 구현**: REST와 HTTP의 개념을 이해하고, HTTP 메서드 및 상태 코드를 적절하게 사용하여 RESTful API를 구현하는 방법을 학습.
2. **레이어드 아키텍처 설계**: 컨트롤러, 서비스, 리포지토리 계층으로 분리하여 유지보수성과 확장성을 고려한 아키텍처 설계 방법을 학습.
3. **Spring Boot와 Spring Security 학습**: Spring Boot로 빠르게 백엔드 서비스를 구축하고, Spring Security를 활용하여 인증 및 권한 관리를 구현.
4. **JWT 기반 인증 구현**: JWT 토큰을 사용하여 인증 시스템을 설계하고, 토큰 발급 및 검증을 통한 보안 처리 방법을 학습.
5. **데이터베이스 설계 및 JPA 활용**: 관계형 데이터베이스를 설계하고, JPA를 사용하여 객체지향적인 데이터 처리를 학습.
6. **단위 테스트와 통합 테스트**: JUnit과 Spring Boot Test를 사용하여 단위 테스트 및 통합 테스트를 수행하는 방법을 익힘.
7. **Swagger를 활용한 API 문서화**: Swagger를 사용하여 API 문서화를 진행하고, 각 엔드포인트 및 데이터 스키마를 자동으로 문서화하는 방법을 익힘.
8. **Docker를 사용한 배포 환경 구축**: Docker를 활용해 애플리케이션을 컨테이너화하고, 배포 및 실행 환경을 설정하는 방법을 학습.
9. **GitHub Actions와 Docker Hub를 활용한 CI/CD**: GitHub Actions를 사용하여 코드를 GitHub에 push하면 자동으로 Docker 이미지를 빌드하고, 이를 Docker Hub에 push하는 CI/CD 파이프라인 구축 방법을 학습.
10. **Liquibase를 활용한 데이터베이스 마이그레이션**: Liquibase를 이용해 애플리케이션 최초 실행 시 데이터베이스 스키마를 자동으로 초기화하고, 스키마 변경을 관리하는 방법을 학습.

### 1.4 기술 스택
- **언어**: Kotlin
- **프레임워크**: Spring Boot
- **보안**: Spring Security, JWT, HTTPS
- **데이터베이스**: MySQL, JPA, Liquibase
- **기타 기술**: Swagger, Docker, Insomnia

---

## 2. 시스템 아키텍처 (System Architecture)
### 2.1 레이어드 아키텍처
프로젝트는 전형적인 **레이어드 아키텍처**로 설계되었습니다. 이는 각 계층이 독립적으로 동작하며, 유지보수성과 확장성을 높이는 데 중점을 둡니다. 각 계층의 역할은 다음과 같습니다:
- **컨트롤러 계층 (Controller Layer)**: 클라이언트의 요청을 처리하고, 비즈니스 로직을 실행하기 위해 서비스 계층과 상호작용합니다. 클라이언트에게 적절한 응답을 반환하는 역할을 담당합니다.
- **서비스 계층 (Service Layer)**: 비즈니스 로직을 처리하는 중간 계층으로, 컨트롤러와 리포지토리 계층을 연결합니다. 이 계층에서 권한 검증 및 비즈니스 규칙을 적용합니다.
- **리포지토리 계층 (Repository Layer)**: 데이터베이스와 상호작용하는 계층으로, JPA를 사용하여 데이터를 저장, 조회, 수정, 삭제하는 책임을 집니다. 데이터베이스와의 직접적인 통신을 추상화하여 객체와 데이터베이스 간의 상호작용을 단순화합니다.

### 2.2 주요 컴포넌트
#### 2.2.1 도메인 관리 컴포넌트
- 사용자, 게시판, 게시글, 댓글, 역할 등의 도메인에 대해 **CRUD 기능**(생성, 조회, 수정, 삭제)을 처리합니다. 각 도메인에 맞는 데이터 관리와 서비스 계층과의 상호작용을 통해 비즈니스 로직을 처리합니다.
    - **사용자 관리 (User Management)**
    - **게시판 관리 (Board Management)**
    - **게시글 관리 (Post Management)**
    - **댓글 관리 (Comment Management)**
    - **역할 관리 (Role Management)**
#### 2.2.2 인증 및 JWT 관리
- 로그인, 회원가입, JWT 토큰 발급 및 갱신을 처리하여 클라이언트가 안전하게 시스템에 접근할 수 있도록 합니다. JWT를 사용하여 인증된 사용자를 식별하고, 요청의 유효성을 검증합니다.
#### 2.2.3 권한 관리
- 사용자의 역할과 관리자/스태프 권한에 따라 특정 리소스나 기능에 대한 접근 권한을 설정하고 관리합니다. 시스템 내 자원에 대한 접근을 제어하여 사용자가 권한에 맞는 작업만 수행할 수 있도록 보장합니다.

### 2.3 데이터베이스 설계
프로젝트의 데이터베이스는 관계형 데이터베이스인 **MySQL**을 기반으로 설계되었습니다. 주요 테이블 간의 관계는 아래 **ERD**에서 확인할 수 있습니다.

![ERD](./docs/ERD.png)

데이터베이스는 다음과 같은 주요 테이블로 구성되어 있습니다:
- **User**: 사용자 정보를 저장합니다.
- **Board**: 게시판 정보를 저장합니다.
- **Post**: 게시글 정보를 저장합니다.
- **Comment**: 댓글 정보를 저장합니다.
- **Role**: 사용자의 역할 정보를 저장합니다.
- **UserLikePost**: 사용자와 게시글의 좋아요 관계를 매핑합니다. 

#### 테이블 간의 주요 관계
- **User - Role**: 사용자는 하나의 역할을 가질 수 있으며(다대일 관계), 역할에 따라 시스템 내의 접근 권한이 달라집니다.
- **Board - Role**: 게시판은 하나의 최소 접근 가능 역할을 가질 수 있습니다(다대일 관계).
- **Board - Post**: 하나의 게시판에는 여러 게시글이 존재할 수 있습니다(다대일 관계).
- **Post - Comment**: 하나의 게시글에는 여러 댓글이 달릴 수 있습니다(다대일 관계).
- **User - Post**: 사용자는 여러 게시글을 작성할 수 있습니다(다대일 관계).
- **User - Comment**: 사용자는 여러 댓글을 작성할 수 있습니다(다대일 관계).
- **User - Post(좋아요)**: 사용자는 여러 게시글을 즐겨찾기할 수 있으며, 하나의 게시글은 여러 사용자가 즐겨찾기할 수 있습니다(다대다 관계). UserLikePost 중간 테이블를 통해 매핑됩니다.

---

## 3. 테스트 및 검증 (Testing & Validation)
### 3.1 유닛 테스트
- **JUnit**을 사용하여 개별 메서드와 클래스의 기능을 검증하는 유닛 테스트를 작성하였습니다.
- 각 메서드들이 의도한 대로 동작하는지 확인하였습니다.

### 3.2 통합 테스트
- **Spring Boot Test**를 활용하여 애플리케이션의 통합 테스트를 수행하였습니다.
- 컨트롤러, 서비스, 리포지토리 계층 간의 상호작용이 올바르게 이루어지는지 검증하였습니다.
- 실제 데이터베이스와의 연동을 통해 전체적인 흐름을 테스트하였습니다.

### 3.3 기능 테스트
- **Insomnia**를 사용하여 API의 엔드포인트를 직접 호출하고, 기능 테스트를 수행하였습니다.
- 각 API가 예상된 응답을 반환하는지 확인하고, 인증 및 권한 부여가 올바르게 작동하는지 검증하였습니다.
- 예외 상황 및 에러 처리 로직도 함께 테스트하였습니다.

---

## 4. 에러 처리 (Error Handling)
### 4.1 전역 예외 처리
- 애플리케이션 전역에서 발생하는 예외는 **@RestControllerAdvice**와 **ResponseEntityExceptionHandler**를 사용하여 처리합니다.
- 주요 예외 처리 내용은 다음과 같습니다:
  - **400 Bad Request**: 잘못된 요청(`MethodArgumentNotValidException`, `IllegalArgumentException`)에 대해 처리하며, 클라이언트에 적절한 에러 응답을 반환합니다.
  - **401 Unauthorized**: 인증 실패 시(`BadCredentialsException`), 사용자에게 인증 실패 응답을 반환합니다.
  - **404 Not Found**: 리소스를 찾을 수 없을 때(`NotFoundException`), 404 상태 코드를 반환하여 클라이언트에 알립니다.
  - **409 Conflict**: 데이터의 충돌 상황(`IllegalStateException`)에 대한 응답을 처리합니다.

### 4.2 스프링 시큐리티 예외 처리
- **Spring Security 필터 체인**에서 발생하는 예외는 전역 예외 처리기에서 처리되지 않으므로, 별도의 처리기를 사용하여 처리합니다.
  - **CustomAccessDeniedHandler**: `AccessDeniedException`이 발생할 때, 403 Forbidden 상태 코드를 반환하여 권한이 부족한 사용자에게 알립니다.
  - **CustomAuthenticationEntryPoint**: 인증되지 않은 요청에서 발생하는 `AuthenticationException`에 대해 401 Unauthorized 상태 코드를 반환합니다.

### 4.3 HTTP 상태 코드 매핑
- 각 예외 상황에 따라 적절한 HTTP 상태 코드를 매핑하여 클라이언트에 명확한 응답을 제공합니다:
  - **400 Bad Request**: 잘못된 요청
  - **401 Unauthorized**: 인증 실패
  - **403 Forbidden**: 권한 부족
  - **404 Not Found**: 리소스 미존재
  - **409 Conflict**: 데이터 충돌
  - **500 Internal Server Error**: 서버 내부 오류

### 4.4 에러 메시지 반환
- 모든 예외 처리 응답은 **ErrorResponse** 객체를 통해 일관된 형식으로 반환됩니다.
- **ErrorResponse**는 다음과 같은 필드를 포함합니다:
  - **status**: HTTP 상태 코드
  - **message**: 에러 메시지
  - **details**: 에러와 관련된 세부 정보 (예: 요청된 URI)
- 이를 통해 클라이언트에게 명확하고 일관된 에러 정보를 전달할 수 있습니다.

---

## 5. 인증 및 보안 (Authentication & Security)
### 5.1 인증
- 본 프로젝트는 **JWT(Json Web Token)** 기반의 인증 방식을 사용합니다. 사용자가 로그인에 성공하면 서버는 JWT를 발급하고, 이후 클라이언트는 이 토큰을 사용해 서버와 통신합니다.
- **JWT**는 각 요청의 헤더에 포함되어 전달되며, 서버는 이를 검증하여 요청자의 신원을 확인합니다.
- 인증 절차는 다음과 같습니다:
  1. 사용자가 로그인 요청을 보냅니다.
  2. 서버가 사용자 정보를 확인하고, 인증이 성공하면 **JWT**를 발급합니다.
  3. 클라이언트는 헤더에 **JWT**를 포함하여 요청을 보내며, 서버는 이를 통해 인증을 처리합니다.

### 5.2 JWT 구성 및 처리
- **JWT 토큰 구조**는 **헤더(Header)**, **페이로드(Payload)**, **서명(Signature)** 로 구성됩니다.
  - **헤더**: 서명에 사용된 알고리즘 정보를 포함.
  - **페이로드**: 사용자 ID, 사용자 이름, 역할, 스태프/관리자 여부 등의 클레임을 포함하여, 사용자의 인증 정보를 담고 있습니다.
  - **서명**: 토큰이 변조되지 않았음을 확인하기 위해 서버의 비밀 키로 서명.
- **Access Token**과 **Refresh Token**은 각각 다른 유효 기간을 가집니다:
  - **Access Token**: 짧은 유효 기간을 가지며, 클라이언트가 서버 자원에 접근할 때 사용됩니다.
  - **Refresh Token**: 만료된 Access Token을 갱신하기 위해 사용되며, 더 긴 유효 기간을 가집니다.
- 토큰 생성 및 처리 절차:
  1. **Access Token**과 **Refresh Token**은 사용자 인증 후 발급됩니다.
  2. 클라이언트는 **Authorization 헤더**에 "Bearer {token}" 형식으로 **Access Token**을 포함하여 요청을 보냅니다.
  3. 서버는 토큰의 서명을 검증하고, 토큰에 포함된 클레임을 바탕으로 사용자의 인증 및 권한을 확인합니다.
  4. 토큰이 만료되거나 유효하지 않으면 요청은 거부됩니다.
- 주요 기능:
  - **토큰 생성**: 사용자 정보와 유효 기간을 바탕으로 Access Token 및 Refresh Token을 생성.
  - **토큰 검증**: 서명과 만료 시간을 확인하여 토큰의 유효성을 검증.
  - **토큰에서 사용자 정보 추출**: 토큰에서 사용자 ID, 이름, 역할 등의 정보를 추출하여 인증 및 인가 과정에 활용.
  - **Authorization 헤더에서 토큰 추출**: HTTP 요청의 Authorization 헤더에서 토큰을 추출하여 처리.

### 5.3 권한 관리
- 본 프로젝트에서는 **ABAC(Attribute-Based Access Control)** 방식으로 권한을 관리합니다. 사용자의 속성 및 요청 리소스에 따라 접근 권한이 부여됩니다.
- 사용자는 일반/스태프/관리자 중 하나에 속하며, 일반 사용자는 하나의 **Role**(역할)을 가집니다. 각 속성과 역할에 따라 접근할 수 있는 리소스와 기능이 제한됩니다.
- 권한 부여 과정은 다음과 같습니다:
  1. 서버는 요청을 받은 후, **JWT**를 통해 사용자의 정보를 확인합니다.
  2. 사용자의 역할과 속성을 바탕으로 요청된 자원에 접근할 수 있는지 확인합니다.
  3. 접근 권한이 없을 경우 **403 Forbidden** 응답을 반환합니다.

### 5.4 보안 적용
- **Spring Security**를 활용하여 인증 및 권한 관리를 구현하였습니다.
- **HTTPS**를 사용하여 모든 클라이언트-서버 간의 통신을 암호화하여 보안성을 보장합니다.
- 비밀번호는 **BCrypt** 알고리즘을 사용하여 안전하게 해싱한 후 저장합니다.

### 5.5 세션 관리
- JWT 기반의 인증을 사용하므로, 서버는 **세션을 관리하지 않으며** 상태 비저장(Stateless) 방식을 따릅니다.
- 클라이언트는 매 요청마다 **JWT**를 포함해 인증을 처리하므로, 서버는 클라이언트 상태에 대한 정보를 유지하지 않습니다.